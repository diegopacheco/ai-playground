<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code City Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(240,248,255,0.9));
            color: #333;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            z-index: 100;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        #info h2 { margin-bottom: 10px; color: #2c5282; }
        #info p { margin: 5px 0; font-size: 14px; opacity: 0.9; }
        #tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(255,255,255,0.98), rgba(240,248,255,0.98));
            color: #333;
            padding: 24px 32px;
            border-radius: 12px;
            font-size: 22px;
            line-height: 1.6;
            pointer-events: none;
            display: none;
            z-index: 200;
            border: 2px solid rgba(44,82,130,0.3);
            box-shadow: 0 8px 40px rgba(0,0,0,0.2);
            min-width: 350px;
        }
        #tooltip strong { color: #2c5282; font-size: 26px; }
        #legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(240,248,255,0.9));
            color: #333;
            padding: 15px;
            border-radius: 12px;
            z-index: 100;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        #legend h4 { margin-bottom: 8px; color: #2c5282; }
        #legend p { font-size: 13px; margin: 4px 0; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(240,248,255,0.9));
            color: #333;
            padding: 12px 16px;
            border-radius: 12px;
            z-index: 100;
            font-size: 12px;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Code City</h2>
        <p id="repo-name">Loading...</p>
        <p id="stats"></p>
    </div>
    <div id="tooltip"></div>
    <div id="legend"></div>
    <div id="controls">
        Mouse: Rotate | Scroll: Zoom | Right-click: Pan
    </div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let buildings = [];
        let labels = [];
        let raycaster, mouse;

        function generateVibrantColor(index, total) {
            const hue = (index / total) * 360;
            const saturation = 70 + Math.random() * 20;
            const lightness = 45 + Math.random() * 15;
            return new THREE.Color(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
        }

        function createWindowTexture(baseColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const color = new THREE.Color(baseColor);
            ctx.fillStyle = color.getStyle();
            ctx.fillRect(0, 0, 128, 512);
            const windowWidth = 16;
            const windowHeight = 24;
            const spacingX = 28;
            const spacingY = 40;
            const offsetX = 10;
            const offsetY = 20;
            for (let y = offsetY; y < 480; y += spacingY) {
                for (let x = offsetX; x < 110; x += spacingX) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.fillRect(x, y, windowWidth, windowHeight);
                    ctx.fillStyle = 'rgba(135,206,235,0.4)';
                    ctx.fillRect(x + 2, y + 2, windowWidth - 4, windowHeight - 4);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.needsUpdate = true;
            return texture;
        }

        function createTextSprite(text, position) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 64;
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, 512, 64);
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillText(text, 258, 34);
            ctx.fillStyle = '#1a365d';
            ctx.fillText(text, 256, 32);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(2.5, 0.35, 1);
            return sprite;
        }

        function createBuilding(file, x, z, height, baseColor) {
            const group = new THREE.Group();
            const buildingWidth = 0.9;
            const buildingDepth = 0.9;
            const windowTexture = createWindowTexture(baseColor);
            windowTexture.repeat.set(1, Math.ceil(height / 4));
            const materials = [
                new THREE.MeshStandardMaterial({ map: windowTexture, metalness: 0.1, roughness: 0.7 }),
                new THREE.MeshStandardMaterial({ map: windowTexture, metalness: 0.1, roughness: 0.7 }),
                new THREE.MeshStandardMaterial({ color: baseColor.clone().multiplyScalar(1.1), metalness: 0.2, roughness: 0.5 }),
                new THREE.MeshStandardMaterial({ color: baseColor.clone().multiplyScalar(0.7), metalness: 0.1, roughness: 0.8 }),
                new THREE.MeshStandardMaterial({ map: windowTexture, metalness: 0.1, roughness: 0.7 }),
                new THREE.MeshStandardMaterial({ map: windowTexture, metalness: 0.1, roughness: 0.7 })
            ];
            const geometry = new THREE.BoxGeometry(buildingWidth, height, buildingDepth);
            const building = new THREE.Mesh(geometry, materials);
            building.position.set(x, height / 2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            building.userData = file;
            group.add(building);
            const roofColor = baseColor.clone().multiplyScalar(0.85);
            const roofMat = new THREE.MeshStandardMaterial({ color: roofColor, metalness: 0.4, roughness: 0.3 });
            const tier1H = 0.15;
            const tier1 = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth + 0.1, tier1H, buildingDepth + 0.1), roofMat);
            tier1.position.set(x, height + tier1H / 2, z);
            tier1.castShadow = true;
            tier1.userData = file;
            group.add(tier1);
            const tier2H = 0.12;
            const tier2 = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth * 0.7, tier2H, buildingDepth * 0.7), roofMat);
            tier2.position.set(x, height + tier1H + tier2H / 2, z);
            tier2.castShadow = true;
            tier2.userData = file;
            group.add(tier2);
            const domeRadius = buildingWidth * 0.35;
            const dome = new THREE.Mesh(
                new THREE.SphereGeometry(domeRadius, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshStandardMaterial({ color: roofColor.clone().multiplyScalar(1.2), metalness: 0.5, roughness: 0.2 })
            );
            dome.position.set(x, height + tier1H + tier2H, z);
            dome.castShadow = true;
            dome.userData = file;
            group.add(dome);
            const spireHeight = height * 0.08 + 0.3;
            const spire = new THREE.Mesh(
                new THREE.ConeGeometry(0.06, spireHeight, 8),
                new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 })
            );
            spire.position.set(x, height + tier1H + tier2H + domeRadius + spireHeight / 2 - 0.05, z);
            spire.castShadow = true;
            group.add(spire);
            const baseHeight = 0.15;
            const baseGeometry = new THREE.BoxGeometry(buildingWidth + 0.2, baseHeight, buildingDepth + 0.2);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.1, roughness: 0.9 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(x, baseHeight / 2, z);
            base.receiveShadow = true;
            base.userData = file;
            group.add(base);
            const displayName = file.name.length > 10 ? file.name.substring(0, 8) + '..' : file.name;
            const label = createTextSprite(displayName, new THREE.Vector3(x, height + 0.8, z));
            group.add(label);
            labels.push(label);
            return { group, building, meshes: [building, tier1, tier2, dome, base] };
        }

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(50, 40, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.1;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xfffacd, 1.2);
            sunLight.position.set(30, 50, 25);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 5;
            sunLight.shadow.camera.far = 150;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);

            const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x98d982, 0.4);
            scene.add(hemisphereLight);

            const fillLight = new THREE.DirectionalLight(0xfff5e6, 0.3);
            fillLight.position.set(-20, 25, -20);
            scene.add(fillLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createClouds();

            try {
                const response = await fetch('data.json');
                const data = await response.json();
                createCity(data);
                updateInfo(data);
                updateLegend(data);
            } catch (error) {
                document.getElementById('repo-name').textContent = 'Error loading data.json - Run analyze.py first';
            }

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);

            animate();
        }

        function createClouds() {
            const cloudGeometry = new THREE.SphereGeometry(1, 8, 8);
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.85,
                roughness: 1
            });
            for (let i = 0; i < 8; i++) {
                const cloudGroup = new THREE.Group();
                const numPuffs = 2 + Math.floor(Math.random() * 2);
                for (let j = 0; j < numPuffs; j++) {
                    const puff = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    const scale = 0.4 + Math.random() * 0.5;
                    puff.scale.set(scale * 1.5, scale, scale * 1.2);
                    puff.position.set(j * 0.8 - numPuffs * 0.4, Math.random() * 0.3, Math.random() * 0.4);
                    cloudGroup.add(puff);
                }
                cloudGroup.position.set(
                    (Math.random() - 0.5) * 25,
                    12 + Math.random() * 6,
                    (Math.random() - 0.5) * 25
                );
                scene.add(cloudGroup);
            }
        }

        function createCobblestoneTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#8b7355';
            ctx.fillRect(0, 0, 256, 256);
            const stoneColors = ['#a08060', '#9a7a5a', '#8b7355', '#7d6548', '#6b5740'];
            for (let y = 0; y < 256; y += 32) {
                for (let x = 0; x < 256; x += 32) {
                    const offsetX = (y % 64 === 0) ? 0 : 16;
                    ctx.fillStyle = stoneColors[Math.floor(Math.random() * stoneColors.length)];
                    ctx.beginPath();
                    ctx.roundRect(x + offsetX + 2, y + 2, 28, 28, 4);
                    ctx.fill();
                    ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    ctx.fillRect(x + offsetX + 3, y + 3, 26, 2);
                    ctx.fillStyle = 'rgba(0,0,0,0.15)';
                    ctx.fillRect(x + offsetX + 3, y + 26, 26, 2);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.3, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.set(x, 0.15, z);
            trunk.castShadow = true;
            group.add(trunk);
            const foliageColors = [0x2d5a27, 0x3a7233, 0x4a8a43];
            for (let i = 0; i < 3; i++) {
                const size = 0.25 - i * 0.06;
                const foliageGeo = new THREE.ConeGeometry(size, 0.3, 8);
                const foliageMat = new THREE.MeshStandardMaterial({
                    color: foliageColors[i],
                    roughness: 0.8
                });
                const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                foliage.position.set(x, 0.3 + i * 0.22, z);
                foliage.castShadow = true;
                group.add(foliage);
            }
            return group;
        }

        function createFountain(x, z) {
            const group = new THREE.Group();
            const baseGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.1, 16);
            const stoneMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.7 });
            const base = new THREE.Mesh(baseGeo, stoneMat);
            base.position.set(x, 0.05, z);
            base.receiveShadow = true;
            group.add(base);
            const poolGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.06, 16);
            const waterMat = new THREE.MeshStandardMaterial({
                color: 0x4a90d9,
                roughness: 0.1,
                metalness: 0.3,
                transparent: true,
                opacity: 0.8
            });
            const pool = new THREE.Mesh(poolGeo, waterMat);
            pool.position.set(x, 0.13, z);
            group.add(pool);
            const pillarGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.35, 8);
            const pillar = new THREE.Mesh(pillarGeo, stoneMat);
            pillar.position.set(x, 0.28, z);
            pillar.castShadow = true;
            group.add(pillar);
            const topGeo = new THREE.SphereGeometry(0.07, 12, 12);
            const top = new THREE.Mesh(topGeo, stoneMat);
            top.position.set(x, 0.5, z);
            top.castShadow = true;
            group.add(top);
            return group;
        }

        function createLampPost(x, z) {
            const group = new THREE.Group();
            const postGeo = new THREE.CylinderGeometry(0.02, 0.025, 0.6, 8);
            const postMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.8, roughness: 0.3 });
            const post = new THREE.Mesh(postGeo, postMat);
            post.position.set(x, 0.3, z);
            post.castShadow = true;
            group.add(post);
            const lampGeo = new THREE.SphereGeometry(0.05, 12, 12);
            const lampMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
            const lamp = new THREE.Mesh(lampGeo, lampMat);
            lamp.position.set(x, 0.65, z);
            group.add(lamp);
            return group;
        }

        let people = [];
        function createPerson(targetX, targetZ, buildingHeight) {
            const group = new THREE.Group();
            const bodyColors = [0x2563eb, 0xdc2626, 0x16a34a, 0x9333ea, 0xea580c, 0x0891b2];
            const bodyColor = bodyColors[Math.floor(Math.random() * bodyColors.length)];
            const bodyGeo = new THREE.CapsuleGeometry(0.03, 0.08, 4, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.07;
            group.add(body);
            const headGeo = new THREE.SphereGeometry(0.025, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xfdbf6f });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.14;
            group.add(head);
            const angle = Math.random() * Math.PI * 2;
            const startDist = 2 + Math.random() * 2;
            group.position.set(
                targetX + Math.cos(angle) * startDist,
                0,
                targetZ + Math.sin(angle) * startDist
            );
            group.userData = {
                targetX: targetX,
                targetZ: targetZ,
                speed: 0.005 + Math.random() * 0.01,
                arrived: false
            };
            return group;
        }

        function createCity(data) {
            const files = data.files;
            if (!files.length) return;

            const maxCommits = Math.max(...files.map(f => f.commits || 1));
            const gridSize = Math.ceil(Math.sqrt(files.length));
            const spacing = 1.5;
            const maxHeight = 8;

            const groundSize = gridSize * spacing + 10;

            const waterSize = groundSize + 8;
            const waterGeo = new THREE.PlaneGeometry(waterSize, waterSize);
            const waterMat = new THREE.MeshStandardMaterial({
                color: 0x2a6099,
                metalness: 0.4,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -0.15;
            water.receiveShadow = true;
            scene.add(water);

            const cobbleTexture = createCobblestoneTexture();
            cobbleTexture.repeat.set(groundSize / 4, groundSize / 4);
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: cobbleTexture,
                metalness: 0.1,
                roughness: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            const edgeWidth = 0.3;
            const edgeMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
            const edges = [
                { pos: [0, 0.1, -groundSize/2], size: [groundSize, 0.2, edgeWidth] },
                { pos: [0, 0.1, groundSize/2], size: [groundSize, 0.2, edgeWidth] },
                { pos: [-groundSize/2, 0.1, 0], size: [edgeWidth, 0.2, groundSize] },
                { pos: [groundSize/2, 0.1, 0], size: [edgeWidth, 0.2, groundSize] }
            ];
            edges.forEach(e => {
                const edge = new THREE.Mesh(new THREE.BoxGeometry(...e.size), edgeMat);
                edge.position.set(...e.pos);
                edge.castShadow = true;
                scene.add(edge);
            });

            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.95 });
            const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.85 });
            const offsetX = (gridSize * spacing) / 2;
            const offsetZ = (gridSize * spacing) / 2;

            for (let i = 0; i <= gridSize; i++) {
                const roadH = new THREE.Mesh(new THREE.PlaneGeometry(groundSize - 2, 0.5), roadMaterial);
                roadH.rotation.x = -Math.PI / 2;
                roadH.position.set(0, 0.01, i * spacing - offsetZ);
                scene.add(roadH);
                const sideH1 = new THREE.Mesh(new THREE.BoxGeometry(groundSize - 2, 0.05, 0.1), sidewalkMat);
                sideH1.position.set(0, 0.025, i * spacing - offsetZ - 0.3);
                scene.add(sideH1);
                const sideH2 = new THREE.Mesh(new THREE.BoxGeometry(groundSize - 2, 0.05, 0.1), sidewalkMat);
                sideH2.position.set(0, 0.025, i * spacing - offsetZ + 0.3);
                scene.add(sideH2);

                const roadV = new THREE.Mesh(new THREE.PlaneGeometry(0.5, groundSize - 2), roadMaterial);
                roadV.rotation.x = -Math.PI / 2;
                roadV.position.set(i * spacing - offsetX, 0.01, 0);
                scene.add(roadV);
                const sideV1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, groundSize - 2), sidewalkMat);
                sideV1.position.set(i * spacing - offsetX - 0.3, 0.025, 0);
                scene.add(sideV1);
                const sideV2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, groundSize - 2), sidewalkMat);
                sideV2.position.set(i * spacing - offsetX + 0.3, 0.025, 0);
                scene.add(sideV2);
            }

            files.forEach((file, index) => {
                const row = Math.floor(index / gridSize);
                const col = index % gridSize;
                const commits = file.commits || 1;
                const height = Math.max(1, (commits / maxCommits) * maxHeight);
                const baseColor = generateVibrantColor(index, files.length);
                const x = col * spacing - offsetX;
                const z = row * spacing - offsetZ;
                const { group, meshes } = createBuilding(file, x, z, height, baseColor);
                scene.add(group);
                buildings.push(...meshes);
            });

            const treePositions = [];
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = groundSize / 2 - 1.5;
                treePositions.push([Math.cos(angle) * radius, Math.sin(angle) * radius]);
            }
            treePositions.forEach(([tx, tz]) => {
                scene.add(createTree(tx, tz));
            });

            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + Math.PI / 8;
                const radius = groundSize / 2 - 0.8;
                scene.add(createLampPost(Math.cos(angle) * radius, Math.sin(angle) * radius));
            }

            if (gridSize > 2) {
                scene.add(createFountain(0, 0));
            }

            const maxCommitsVal = Math.max(...files.map(f => f.commits || 1));
            files.forEach((file, index) => {
                const row = Math.floor(index / gridSize);
                const col = index % gridSize;
                const x = col * spacing - offsetX;
                const z = row * spacing - offsetZ;
                const commits = file.commits || 1;
                const numPeople = Math.min(5, Math.ceil((commits / maxCommitsVal) * 5));
                for (let p = 0; p < numPeople; p++) {
                    const person = createPerson(x, z, 1);
                    scene.add(person);
                    people.push(person);
                }
            });

            const citySize = gridSize * spacing;
            camera.position.set(citySize * 1.2, citySize * 0.9, citySize * 1.2);
            controls.target.set(0, 1, 0);
        }

        function updateInfo(data) {
            document.getElementById('repo-name').textContent = data.repo_url;
            document.getElementById('stats').textContent = `${data.total_files} files | ${data.total_loc.toLocaleString()} LOC | ${data.total_commits || 0} changes`;
        }

        function updateLegend(data) {
            const legend = document.getElementById('legend');
            const maxCommits = Math.max(...data.files.map(f => f.commits || 1));
            legend.innerHTML = `<h4>Building Height = Git Commits</h4>
                <p>Tallest: ${maxCommits} commits</p>
                <p>Each building = unique color</p>`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(buildings);
            const tooltip = document.getElementById('tooltip');
            if (intersects.length > 0) {
                const file = intersects[0].object.userData;
                if (file && file.name) {
                    tooltip.innerHTML = `<strong>${file.name}</strong><br>Path: ${file.path}<br>Lines: ${file.loc.toLocaleString()}<br>Commits: ${file.commits || 1}<br>Type: ${file.extension}`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = event.clientX + 15 + 'px';
                    tooltip.style.top = event.clientY + 15 + 'px';
                }
            } else {
                tooltip.style.display = 'none';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            labels.forEach(label => {
                label.quaternion.copy(camera.quaternion);
            });
            people.forEach(person => {
                if (!person.userData.arrived) {
                    const dx = person.userData.targetX - person.position.x;
                    const dz = person.userData.targetZ - person.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist > 0.15) {
                        person.position.x += (dx / dist) * person.userData.speed;
                        person.position.z += (dz / dist) * person.userData.speed;
                        person.rotation.y = Math.atan2(dx, dz);
                        person.position.y = Math.sin(Date.now() * 0.015) * 0.02;
                    } else {
                        person.userData.arrived = true;
                        person.visible = false;
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const startDist = 2 + Math.random() * 2;
                            person.position.set(
                                person.userData.targetX + Math.cos(angle) * startDist,
                                0,
                                person.userData.targetZ + Math.sin(angle) * startDist
                            );
                            person.userData.arrived = false;
                            person.visible = true;
                        }, 1000 + Math.random() * 3000);
                    }
                }
            });
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
