<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code City Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(240,248,255,0.9));
            color: #333;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            z-index: 100;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        #info h2 { margin-bottom: 10px; color: #2c5282; }
        #info p { margin: 5px 0; font-size: 14px; opacity: 0.9; }
        #tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(255,255,255,0.98), rgba(240,248,255,0.98));
            color: #333;
            padding: 24px 32px;
            border-radius: 12px;
            font-size: 22px;
            line-height: 1.6;
            pointer-events: none;
            display: none;
            z-index: 200;
            border: 2px solid rgba(44,82,130,0.3);
            box-shadow: 0 8px 40px rgba(0,0,0,0.2);
            min-width: 350px;
        }
        #tooltip strong { color: #2c5282; font-size: 26px; }
        #legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(240,248,255,0.9));
            color: #333;
            padding: 15px;
            border-radius: 12px;
            z-index: 100;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        #legend h4 { margin-bottom: 8px; color: #2c5282; }
        #legend p { font-size: 13px; margin: 4px 0; }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(240,248,255,0.9));
            color: #333;
            padding: 12px 16px;
            border-radius: 12px;
            z-index: 100;
            font-size: 12px;
            border: 1px solid rgba(0,0,0,0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Code City</h2>
        <p id="repo-name">Loading...</p>
        <p id="stats"></p>
    </div>
    <div id="tooltip"></div>
    <div id="legend"></div>
    <div id="controls">
        Mouse: Rotate | Scroll: Zoom | Right-click: Pan
    </div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let buildings = [];
        let labels = [];
        let raycaster, mouse;

        function generateVibrantColor(index, total) {
            const hue = (index / total) * 360;
            const saturation = 70 + Math.random() * 20;
            const lightness = 45 + Math.random() * 15;
            return new THREE.Color(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
        }

        function createWindowTexture(baseColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const color = new THREE.Color(baseColor);
            ctx.fillStyle = color.getStyle();
            ctx.fillRect(0, 0, 128, 512);
            const windowWidth = 16;
            const windowHeight = 24;
            const spacingX = 28;
            const spacingY = 40;
            const offsetX = 10;
            const offsetY = 20;
            for (let y = offsetY; y < 480; y += spacingY) {
                for (let x = offsetX; x < 110; x += spacingX) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.fillRect(x, y, windowWidth, windowHeight);
                    ctx.fillStyle = 'rgba(135,206,235,0.4)';
                    ctx.fillRect(x + 2, y + 2, windowWidth - 4, windowHeight - 4);
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.needsUpdate = true;
            return texture;
        }

        function createTextSprite(text, position) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 64;
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, 512, 64);
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillText(text, 258, 34);
            ctx.fillStyle = '#1a365d';
            ctx.fillText(text, 256, 32);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(4, 0.5, 1);
            return sprite;
        }

        function createBuilding(file, x, z, height, baseColor) {
            const group = new THREE.Group();
            const buildingWidth = 1.2;
            const buildingDepth = 1.2;
            const windowTexture = createWindowTexture(baseColor);
            windowTexture.repeat.set(1, Math.ceil(height / 4));
            const materials = [
                new THREE.MeshStandardMaterial({ map: windowTexture, metalness: 0.1, roughness: 0.7 }),
                new THREE.MeshStandardMaterial({ map: windowTexture, metalness: 0.1, roughness: 0.7 }),
                new THREE.MeshStandardMaterial({ color: baseColor.clone().multiplyScalar(1.1), metalness: 0.2, roughness: 0.5 }),
                new THREE.MeshStandardMaterial({ color: baseColor.clone().multiplyScalar(0.7), metalness: 0.1, roughness: 0.8 }),
                new THREE.MeshStandardMaterial({ map: windowTexture, metalness: 0.1, roughness: 0.7 }),
                new THREE.MeshStandardMaterial({ map: windowTexture, metalness: 0.1, roughness: 0.7 })
            ];
            const geometry = new THREE.BoxGeometry(buildingWidth, height, buildingDepth);
            const building = new THREE.Mesh(geometry, materials);
            building.position.set(x, height / 2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            building.userData = file;
            group.add(building);
            const roofColor = baseColor.clone().multiplyScalar(0.85);
            const roofMat = new THREE.MeshStandardMaterial({ color: roofColor, metalness: 0.4, roughness: 0.3 });
            const tier1H = 0.15;
            const tier1 = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth + 0.1, tier1H, buildingDepth + 0.1), roofMat);
            tier1.position.set(x, height + tier1H / 2, z);
            tier1.castShadow = true;
            tier1.userData = file;
            group.add(tier1);
            const tier2H = 0.12;
            const tier2 = new THREE.Mesh(new THREE.BoxGeometry(buildingWidth * 0.7, tier2H, buildingDepth * 0.7), roofMat);
            tier2.position.set(x, height + tier1H + tier2H / 2, z);
            tier2.castShadow = true;
            tier2.userData = file;
            group.add(tier2);
            const domeRadius = buildingWidth * 0.35;
            const dome = new THREE.Mesh(
                new THREE.SphereGeometry(domeRadius, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2),
                new THREE.MeshStandardMaterial({ color: roofColor.clone().multiplyScalar(1.2), metalness: 0.5, roughness: 0.2 })
            );
            dome.position.set(x, height + tier1H + tier2H, z);
            dome.castShadow = true;
            dome.userData = file;
            group.add(dome);
            const spireHeight = height * 0.08 + 0.3;
            const spire = new THREE.Mesh(
                new THREE.ConeGeometry(0.06, spireHeight, 8),
                new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 })
            );
            spire.position.set(x, height + tier1H + tier2H + domeRadius + spireHeight / 2 - 0.05, z);
            spire.castShadow = true;
            group.add(spire);
            const baseHeight = 0.15;
            const baseGeometry = new THREE.BoxGeometry(buildingWidth + 0.2, baseHeight, buildingDepth + 0.2);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.1, roughness: 0.9 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(x, baseHeight / 2, z);
            base.receiveShadow = true;
            base.userData = file;
            group.add(base);
            const displayName = file.name.length > 10 ? file.name.substring(0, 8) + '..' : file.name;
            const label = createTextSprite(displayName, new THREE.Vector3(x, height + 1.5, z));
            group.add(label);
            labels.push(label);
            return { group, building, meshes: [building, tier1, tier2, dome, base] };
        }

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(50, 40, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.1;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xfffacd, 1.2);
            sunLight.position.set(30, 50, 25);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 5;
            sunLight.shadow.camera.far = 150;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);

            const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x98d982, 0.4);
            scene.add(hemisphereLight);

            const fillLight = new THREE.DirectionalLight(0xfff5e6, 0.3);
            fillLight.position.set(-20, 25, -20);
            scene.add(fillLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createClouds();

            try {
                const response = await fetch('data.json');
                const data = await response.json();
                createCity(data);
                updateInfo(data);
                updateLegend(data);
            } catch (error) {
                document.getElementById('repo-name').textContent = 'Error loading data.json - Run analyze.py first';
            }

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);

            animate();
        }

        function createClouds() {
            const cloudGeometry = new THREE.SphereGeometry(1, 8, 8);
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                roughness: 1
            });
            for (let i = 0; i < 10; i++) {
                const cloudGroup = new THREE.Group();
                const numPuffs = 3 + Math.floor(Math.random() * 3);
                for (let j = 0; j < numPuffs; j++) {
                    const puff = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    const scale = 1 + Math.random() * 1.5;
                    puff.scale.set(scale * 1.5, scale, scale * 1.2);
                    puff.position.set(j * 2 - numPuffs, Math.random() * 0.8, Math.random() * 1);
                    cloudGroup.add(puff);
                }
                cloudGroup.position.set(
                    (Math.random() - 0.5) * 80,
                    30 + Math.random() * 15,
                    (Math.random() - 0.5) * 80
                );
                scene.add(cloudGroup);
            }
        }

        function createCity(data) {
            const files = data.files;
            if (!files.length) return;

            const maxCommits = Math.max(...files.map(f => f.commits || 1));
            const gridSize = Math.ceil(Math.sqrt(files.length));
            const spacing = 2;
            const maxHeight = 20;

            const groundSize = gridSize * spacing + 10;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x98d982,
                metalness: 0.0,
                roughness: 1.0
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9 });
            const offsetX = (gridSize * spacing) / 2;
            const offsetZ = (gridSize * spacing) / 2;

            for (let i = 0; i <= gridSize; i++) {
                const roadH = new THREE.Mesh(
                    new THREE.PlaneGeometry(groundSize, 0.3),
                    roadMaterial
                );
                roadH.rotation.x = -Math.PI / 2;
                roadH.position.set(0, 0.01, i * spacing - offsetZ);
                scene.add(roadH);

                const roadV = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.3, groundSize),
                    roadMaterial
                );
                roadV.rotation.x = -Math.PI / 2;
                roadV.position.set(i * spacing - offsetX, 0.01, 0);
                scene.add(roadV);
            }

            files.forEach((file, index) => {
                const row = Math.floor(index / gridSize);
                const col = index % gridSize;
                const commits = file.commits || 1;
                const height = Math.max(1, (commits / maxCommits) * maxHeight);
                const baseColor = generateVibrantColor(index, files.length);
                const x = col * spacing - offsetX;
                const z = row * spacing - offsetZ;
                const { group, meshes } = createBuilding(file, x, z, height, baseColor);
                scene.add(group);
                buildings.push(...meshes);
            });

            const citySize = gridSize * spacing;
            camera.position.set(citySize * 0.8, citySize * 0.6, citySize * 0.8);
            controls.target.set(0, maxHeight / 6, 0);
        }

        function updateInfo(data) {
            document.getElementById('repo-name').textContent = data.repo_url;
            document.getElementById('stats').textContent = `${data.total_files} files | ${data.total_loc.toLocaleString()} LOC | ${data.total_commits || 0} changes`;
        }

        function updateLegend(data) {
            const legend = document.getElementById('legend');
            const maxCommits = Math.max(...data.files.map(f => f.commits || 1));
            legend.innerHTML = `<h4>Building Height = Git Commits</h4>
                <p>Tallest: ${maxCommits} commits</p>
                <p>Each building = unique color</p>`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(buildings);
            const tooltip = document.getElementById('tooltip');
            if (intersects.length > 0) {
                const file = intersects[0].object.userData;
                if (file && file.name) {
                    tooltip.innerHTML = `<strong>${file.name}</strong><br>Path: ${file.path}<br>Lines: ${file.loc.toLocaleString()}<br>Commits: ${file.commits || 1}<br>Type: ${file.extension}`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = event.clientX + 15 + 'px';
                    tooltip.style.top = event.clientY + 15 + 'px';
                }
            } else {
                tooltip.style.display = 'none';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            labels.forEach(label => {
                label.quaternion.copy(camera.quaternion);
            });
            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
