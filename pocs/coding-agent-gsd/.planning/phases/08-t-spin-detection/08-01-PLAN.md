---
phase: 08-t-spin-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [js/main.js, js/stats.js]
autonomous: true

must_haves:
  truths:
    - "T-spin detected only after rotation, not simple drops"
    - "3+ diagonal corners occupied triggers detection"
    - "Mini vs full distinguished by front corner count"
    - "T-spin scoring uses correct base values (100/200/400 mini, 400/800/1200/1600 full)"
    - "T-spin line clears count as difficult clears for B2B"
    - "Zero-line T-spins do not break B2B chain"
  artifacts:
    - path: "js/main.js"
      provides: "lastAction tracking, T-spin detection, T-spin scoring"
      contains: "detectTSpin"
    - path: "js/stats.js"
      provides: "T-spin count tracking"
      contains: "tSpinCount"
  key_links:
    - from: "rotatePiece()"
      to: "lastAction"
      via: "sets lastAction = 'rotation' on successful rotate"
      pattern: "lastAction.*rotation"
    - from: "movePiece()"
      to: "lastAction"
      via: "sets lastAction = 'movement' on move"
      pattern: "lastAction.*movement"
    - from: "lockPieceToBoard()"
      to: "detectTSpin()"
      via: "calls detection before scoring"
      pattern: "detectTSpin"
    - from: "pendingScoreCalc"
      to: "tSpinType"
      via: "stores T-spin type for deferred scoring"
      pattern: "tSpinType"
---

<objective>
Implement T-spin detection logic and integrate scoring into the existing combo/B2B system.

Purpose: Players performing advanced T-spin moves receive recognition and bonus points according to Tetris Guideline standards.
Output: Working T-spin detection with correct mini/full classification, integrated scoring, and B2B compatibility.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-t-spin-detection/08-RESEARCH.md
@.planning/phases/07-combo-system/07-01-SUMMARY.md
@js/main.js
@js/pieces.js
@js/board.js
@js/stats.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add action tracking state and update movement functions</name>
  <files>js/main.js</files>
  <action>
Add state variables at the top of main.js with other game state:
- let lastAction = null;
- let lastKickOffset = null;

Modify rotatePiece() function:
- After successful rotation (when returning true), set lastAction = 'rotation' and lastKickOffset = kick (the wall kick offset that was used)
- The kick variable from the for loop contains the offset [x, y] used

Modify movePiece() function:
- After successful move (when returning true), set lastAction = 'movement' and lastKickOffset = null

Modify hardDrop() function:
- After the while loop completes (before lockPieceToBoard), set lastAction = 'drop' and lastKickOffset = null
- This ensures hard drops into T-shaped holes are not falsely detected as T-spins

Update resetGame() function:
- Add lastAction = null and lastKickOffset = null to the reset block
  </action>
  <verify>
Read js/main.js and confirm:
- lastAction and lastKickOffset declared near other state variables
- rotatePiece sets lastAction = 'rotation' and captures kick offset
- movePiece sets lastAction = 'movement'
- hardDrop sets lastAction = 'drop'
- resetGame clears both tracking variables
  </verify>
  <done>
lastAction tracks whether last piece interaction was rotation, movement, or drop. lastKickOffset captures wall kick used for mini-to-full upgrade detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement T-spin detection function</name>
  <files>js/main.js</files>
  <action>
Add detectTSpin function in main.js (after movePiece/rotatePiece, before lockPieceToBoard):

function getTSpinCorners(piece) {
    const cx = piece.x + 1;
    const cy = piece.y + 1;
    const corners = [
        [cx - 1, cy - 1],
        [cx + 1, cy - 1],
        [cx - 1, cy + 1],
        [cx + 1, cy + 1]
    ];
    const frontCornersMap = [
        [0, 1],
        [1, 3],
        [2, 3],
        [0, 2]
    ];
    return {
        corners: corners,
        frontIndices: frontCornersMap[piece.rotation]
    };
}

function detectTSpin(piece, board, lastAction, lastKickOffset) {
    if (piece.type !== 'T') return null;
    if (lastAction !== 'rotation') return null;
    const { corners, frontIndices } = getTSpinCorners(piece);
    let occupiedCount = 0;
    let frontOccupiedCount = 0;
    corners.forEach(function(corner, idx) {
        const x = corner[0];
        const y = corner[1];
        const isOccupied = (x < 0 || x >= COLS || y >= board.length || (y >= 0 && board[y][x]));
        if (isOccupied) {
            occupiedCount++;
            if (frontIndices.includes(idx)) {
                frontOccupiedCount++;
            }
        }
    });
    if (occupiedCount < 3) return null;
    const isMini = frontOccupiedCount < 2;
    const isWallKickUpgrade = lastKickOffset && (Math.abs(lastKickOffset[0]) + Math.abs(lastKickOffset[1]) === 3);
    if (isMini && !isWallKickUpgrade) {
        return 'mini';
    }
    return 'full';
}

Key implementation notes:
- T-piece center is always at (1,1) in its 3x3 bounding box, so board position is piece.x + 1, piece.y + 1
- Four diagonal corners relative to center
- Front corners depend on rotation (where T is pointing)
- Walls/floor count as occupied (x < 0, x >= COLS, y >= board.length)
- 3+ corners occupied required for any T-spin
- Mini if less than 2 front corners, unless wall kick upgrade applies
- Wall kick upgrade: when kick offset magnitude is 3 (like [1,2] or [2,1]), mini becomes full
  </action>
  <verify>
Read js/main.js and confirm:
- getTSpinCorners function exists and returns corners array and frontIndices
- detectTSpin function exists and checks piece type, lastAction, corner occupancy
- Returns null for non-T pieces, non-rotation actions, or <3 corners occupied
- Returns 'mini' or 'full' based on front corner count and wall kick upgrade
  </verify>
  <done>
detectTSpin correctly identifies T-spin type (null, 'mini', 'full') using 3-corner rule with proper front/back corner classification per rotation state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate T-spin detection and scoring into game loop</name>
  <files>js/main.js, js/stats.js</files>
  <action>
In stats.js:
- Add tSpinCount: 0 to the stats object
- Add tSpinCount: 0 to startSession() reset block
- Add function updateTSpinStats(tSpinType) that increments stats.tSpinCount if tSpinType is not null

In main.js lockPieceToBoard():
- Before updatePiecePlaced(), call detectTSpin and store result: const tSpinType = detectTSpin(currentPiece, board, lastAction, lastKickOffset);
- If tSpinType is not null, call updateTSpinStats(tSpinType)
- Modify isDifficultClear logic: const isDifficultClear = lines.length === 4 || tSpinType !== null;
- Add tSpinType to pendingScoreCalc object: tSpinType: tSpinType
- In the else block (no lines cleared), only reset combo if tSpinType is null (zero-line T-spins preserve combo/B2B)
- After processing, reset: lastAction = null; lastKickOffset = null;

In main.js update() function (where clearingTimer expires):
Add T-spin score calculation before existing score logic:

function calculateTSpinScore(tSpinType, linesCleared, level) {
    const baseScores = {
        mini: [100, 200, 400],
        full: [400, 800, 1200, 1600]
    };
    return (baseScores[tSpinType][linesCleared] || 0) * level;
}

In the clearingTimer block:
- If pendingScoreCalc.tSpinType exists, use calculateTSpinScore instead of linesCleared * pointsPerRow
- Apply B2B 1.5x multiplier to T-spin score if hasB2bBonus is true
- Keep combo bonus calculation unchanged (50 * (combo-1) * level)
  </action>
  <verify>
Read js/main.js and js/stats.js and confirm:
- stats.tSpinCount exists and resets in startSession
- updateTSpinStats function exists
- lockPieceToBoard calls detectTSpin before other processing
- tSpinType included in pendingScoreCalc
- isDifficultClear includes T-spin check
- Zero-line T-spins do not reset combo
- calculateTSpinScore function exists with correct base values
- update() uses T-spin scoring when tSpinType present
- lastAction/lastKickOffset reset after lock
  </verify>
  <done>
T-spin detection fully integrated into game loop. Scoring uses Guideline values (mini 100/200/400, full 400/800/1200/1600 times level), B2B applies 1.5x multiplier, zero-line T-spins preserve B2B chain.
  </done>
</task>

</tasks>

<verification>
1. Run game in browser, place T-piece without rotating - no T-spin detected
2. Rotate T-piece into tight corner with 3+ corners blocked - T-spin detected
3. T-spin with 2 front corners shows 'full', with <2 front corners shows 'mini'
4. T-spin scoring: mini-0 = 100*level, mini-1 = 200*level, mini-2 = 400*level
5. T-spin scoring: full-0 = 400*level, full-1 = 800*level, full-2 = 1200*level, full-3 = 1600*level
6. Consecutive T-spin line clears activate B2B and receive 1.5x multiplier
7. Zero-line T-spin does not break existing B2B chain
</verification>

<success_criteria>
- T-spin detection triggers only after rotation with 3+ occupied corners
- Mini vs full classification correct based on front corners
- T-spin scoring matches Guideline values
- B2B integration works (T-spin line clears are difficult clears)
- Zero-line T-spins preserve B2B state
- Stats track T-spin count
</success_criteria>

<output>
After completion, create `.planning/phases/08-t-spin-detection/08-01-SUMMARY.md`
</output>
