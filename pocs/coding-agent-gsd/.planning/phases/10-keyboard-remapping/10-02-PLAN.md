---
phase: 10-keyboard-remapping
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - admin.html
  - js/admin.js
autonomous: true

must_haves:
  truths:
    - "User can see current key bindings in admin panel"
    - "User can click a binding button to capture new key"
    - "Pressing a key while capturing assigns it to that action"
    - "Conflict detection prevents duplicate bindings"
    - "Restore Defaults button resets all bindings"
    - "Key changes sync to game via BroadcastChannel"
  artifacts:
    - path: "admin.html"
      provides: "Controls section with key binding UI"
      contains: "Controls"
      min_lines: 220
    - path: "js/admin.js"
      provides: "Key capture and binding logic"
      contains: "startCapture"
      min_lines: 130
  key_links:
    - from: "js/admin.js"
      to: "localStorage"
      via: "tetris_keybindings key"
      pattern: "localStorage\\.(get|set)Item.*tetris_keybindings"
    - from: "js/admin.js"
      to: "BroadcastChannel"
      via: "KEYMAP_CHANGE message"
      pattern: "postMessage.*KEYMAP_CHANGE"
---

<objective>
Add key binding UI section to admin panel with capture mode, conflict detection, and restore defaults functionality.

Purpose: Visual interface for users to customize their controls without editing code or localStorage directly.
Output: Controls section in admin.html with binding buttons, capture mode, conflict warnings, and restore defaults button.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-keyboard-remapping/10-RESEARCH.md
@.planning/phases/10-keyboard-remapping/10-01-SUMMARY.md

@admin.html
@js/admin.js
@js/input.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Controls section HTML and CSS to admin.html</name>
  <files>admin.html</files>
  <action>
Add to admin.html:

1. CSS styles (add to existing style block):
   - .key-bindings: display flex, flex-direction column, gap 10px
   - .binding-row: display flex, justify-content space-between, align-items center
   - .action-label: flex 1
   - .key-button: min-width 120px, padding 8px 12px, background #2a2a4a, color #fff, border 1px solid #00ffff, border-radius 4px, cursor pointer, font-family monospace
   - .key-button:hover: background #3a3a5a
   - .key-button.capturing: background #00ffff, color #000, animation pulse 1s infinite
   - @keyframes pulse: 0%,100% opacity 1; 50% opacity 0.7
   - .restore-btn: margin-top 15px, padding 10px, background #ff4444, color #fff, border none, border-radius 4px, cursor pointer, width 100%
   - .restore-btn:hover: background #ff6666

2. Controls section HTML (add BEFORE the Audio section):
   - div.section containing:
   - h2 with text "Controls"
   - div.key-bindings containing 7 binding rows:
     - Move Left: button id="bind-left"
     - Move Right: button id="bind-right"
     - Soft Drop: button id="bind-down"
     - Rotate: button id="bind-rotate"
     - Hard Drop: button id="bind-hardDrop"
     - Hold Piece: button id="bind-hold"
     - Pause: button id="bind-pause"
   - Each row has span.action-label and button.key-button
   - After key-bindings div: button id="restore-defaults" class="restore-btn" with text "Restore Defaults"
  </action>
  <verify>
Open admin.html in browser:
- Controls section visible before Audio section
- 7 binding rows displayed with labels
- Buttons have cyan border styling
- Restore Defaults button is red
  </verify>
  <done>
Controls section exists in admin.html with 7 key binding buttons, proper styling, and Restore Defaults button.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add key binding logic to admin.js</name>
  <files>js/admin.js</files>
  <action>
Add to js/admin.js:

1. Constants at top (after channel declaration):
   - DEFAULT_KEYMAP object (copy from input.js for reference):
     left: ['ArrowLeft'], right: ['ArrowRight'], down: ['ArrowDown'],
     rotate: ['ArrowUp'], hardDrop: ['Space'],
     hold: ['KeyC', 'ShiftLeft', 'ShiftRight'], pause: ['KeyP']
   - ACTION_LABELS object:
     left: 'Move Left', right: 'Move Right', down: 'Soft Drop',
     rotate: 'Rotate', hardDrop: 'Hard Drop', hold: 'Hold Piece', pause: 'Pause'
   - KEY_DISPLAY_NAMES object for common keys:
     ArrowLeft: 'Left Arrow', ArrowRight: 'Right Arrow', ArrowUp: 'Up Arrow',
     ArrowDown: 'Down Arrow', Space: 'Space', ShiftLeft: 'Left Shift',
     ShiftRight: 'Right Shift', KeyC: 'C', KeyP: 'P', etc.

2. State variables:
   - var capturingAction = null
   - var currentKeymap = {}

3. getKeyDisplayName(code) function:
   - Return KEY_DISPLAY_NAMES[code] if exists
   - If code starts with 'Key', return code.charAt(3)
   - If code starts with 'Digit', return code.charAt(5)
   - Otherwise return code

4. getDefaultKeymap() function:
   - Return fresh copy of DEFAULT_KEYMAP with arrays sliced

5. initKeyBindingUI() function:
   - Read localStorage('tetris_keybindings'), parse JSON
   - On error or missing, use getDefaultKeymap()
   - Call updateAllBindingButtons()
   - Loop through ACTION_LABELS keys, call setupBindButton(action)
   - Add click listener to restore-defaults button

6. setupBindButton(action) function:
   - Get button by id 'bind-' + action
   - Add click listener that calls startCapture(action, button)

7. startCapture(action, button) function:
   - Set capturingAction = action
   - Set button.textContent = 'Press a key...'
   - Add 'capturing' class to button
   - Add keydown listener for handleKeyCapture

8. handleKeyCapture(event) function:
   - event.preventDefault() and event.stopPropagation()
   - If capturingAction is null, return
   - Get code = event.code
   - Check for conflict with findConflict(code, capturingAction)
   - If conflict, alert with conflict message and call cancelCapture()
   - If no conflict:
     - Set currentKeymap[capturingAction] = [code]
     - Call saveAndSync()
     - Update button text with getKeyDisplayName(code)
     - Remove 'capturing' class
     - Remove keydown listener
     - Set capturingAction = null

9. cancelCapture() function:
   - If capturingAction is null, return
   - Get button, restore its text from currentKeymap
   - Remove 'capturing' class
   - Remove keydown listener
   - Set capturingAction = null

10. findConflict(code, excludeAction) function:
    - Loop through currentKeymap actions
    - Skip excludeAction
    - If action's keys include code, return action name
    - Return null if no conflict

11. saveAndSync() function:
    - localStorage.setItem('tetris_keybindings', JSON.stringify(currentKeymap))
    - channel.postMessage({ type: 'KEYMAP_CHANGE', payload: { keymap: currentKeymap } })

12. updateAllBindingButtons() function:
    - Loop through currentKeymap
    - Get button by id 'bind-' + action
    - If button and keymap has keys, set button text to joined display names

13. Restore defaults click handler:
    - currentKeymap = getDefaultKeymap()
    - Call saveAndSync()
    - Call updateAllBindingButtons()

14. Add KEYMAP_CHANGE handler to existing channel.onmessage:
    - On KEYMAP_CHANGE, update currentKeymap and call updateAllBindingButtons()

15. Call initKeyBindingUI() at end of file
  </action>
  <verify>
Test key binding functionality:
- Open admin.html, buttons show current key names
- Click a button, it shows "Press a key..." with cyan background
- Press a key, button updates to show new key
- Try binding same key to two actions, alert shows conflict
- Click Restore Defaults, all buttons reset to defaults
- Open game in another tab, verify controls use new bindings
  </verify>
  <done>
Key binding UI fully functional: capture mode, conflict detection, restore defaults, localStorage persistence, BroadcastChannel sync.
  </done>
</task>

</tasks>

<verification>
1. admin.html has Controls section with 7 binding buttons
2. Buttons styled with cyan border, capturing state has pulse animation
3. Restore Defaults button is red
4. Clicking button enters capture mode (shows "Press a key...")
5. Pressing key assigns it and exits capture mode
6. Binding to already-used key shows conflict alert
7. Restore Defaults resets all to arrows/space/C/P
8. localStorage shows updated keybindings after changes
9. Game in other tab responds to binding changes
10. No JavaScript errors in console
</verification>

<success_criteria>
- Controls section visible in admin panel
- All 7 game actions have binding buttons
- Button shows current key assignment (human-readable)
- Capture mode has visual feedback (cyan background, pulse)
- Conflict detection prevents duplicate bindings with alert
- Restore Defaults resets to default keymap
- Changes persist to localStorage
- BroadcastChannel syncs changes to game tab
- Game responds to remapped controls immediately
</success_criteria>

<output>
After completion, create `.planning/phases/10-keyboard-remapping/10-02-SUMMARY.md`
</output>
