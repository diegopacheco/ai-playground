---
phase: 10-keyboard-remapping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/input.js
autonomous: true

must_haves:
  truths:
    - "All game controls use configurable keymap object instead of hardcoded keys"
    - "Key bindings load from localStorage on init"
    - "Key bindings save to localStorage when changed"
    - "Default bindings are restorable from constant"
    - "BroadcastChannel syncs keymap changes across tabs"
  artifacts:
    - path: "js/input.js"
      provides: "Configurable keymap system with DAS"
      exports: ["loadKeymap", "saveKeymap", "restoreDefaults", "getKeymap", "setKeyBinding", "DEFAULT_KEYMAP"]
      min_lines: 120
  key_links:
    - from: "js/input.js"
      to: "localStorage"
      via: "tetris_keybindings key"
      pattern: "localStorage\\.(get|set)Item.*tetris_keybindings"
    - from: "js/input.js"
      to: "BroadcastChannel"
      via: "KEYMAP_CHANGE message"
      pattern: "postMessage.*KEYMAP_CHANGE"
---

<objective>
Refactor input.js to use a configurable keymap object instead of hardcoded key checks, with localStorage persistence and BroadcastChannel sync.

Purpose: Foundation for remappable controls - decouples physical keys from game actions so users can customize bindings.
Output: Refactored js/input.js with keymap object, persistence functions, and cross-tab sync.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-keyboard-remapping/10-RESEARCH.md

@js/input.js
@js/sync.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add keymap constants and state management</name>
  <files>js/input.js</files>
  <action>
Add to the top of js/input.js (after existing keys, keyTimers, DAS constants):

1. DEFAULT_KEYMAP constant object:
   - left: ['ArrowLeft']
   - right: ['ArrowRight']
   - down: ['ArrowDown']
   - rotate: ['ArrowUp']
   - hardDrop: ['Space']
   - hold: ['KeyC', 'ShiftLeft', 'ShiftRight']
   - pause: ['KeyP']

2. Global keymap variable (initially empty object)

3. BroadcastChannel for sync:
   - var inputChannel = new BroadcastChannel('tetris-sync')
   - Use same channel name as sync.js for compatibility

4. loadKeymap() function:
   - Read from localStorage('tetris_keybindings')
   - Wrap JSON.parse in try/catch
   - On parse error or missing data, call restoreDefaults()
   - Store parsed data in keymap variable

5. saveKeymap() function:
   - JSON.stringify keymap to localStorage('tetris_keybindings')
   - Post KEYMAP_CHANGE message via inputChannel with keymap as payload

6. restoreDefaults() function:
   - Create fresh copy of DEFAULT_KEYMAP into keymap
   - Use slice() for each array to avoid reference sharing: keymap[action] = DEFAULT_KEYMAP[action].slice()
   - Loop through all actions in DEFAULT_KEYMAP

7. getKeymap() function:
   - Return the current keymap object (for UI to read)

8. setKeyBinding(action, keyCode) function:
   - Set keymap[action] = [keyCode]
   - Call saveKeymap() to persist and sync

9. BroadcastChannel listener on inputChannel:
   - On KEYMAP_CHANGE message, update local keymap from payload.keymap
  </action>
  <verify>
Verify new functions exist and are callable:
- DEFAULT_KEYMAP is defined with 7 actions
- loadKeymap, saveKeymap, restoreDefaults, getKeymap, setKeyBinding exist
- inputChannel is defined as BroadcastChannel
  </verify>
  <done>
Keymap state management functions exist: DEFAULT_KEYMAP constant, loadKeymap/saveKeymap for persistence, restoreDefaults for reset, getKeymap/setKeyBinding for access, BroadcastChannel for sync.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor getInput to use keymap lookups</name>
  <files>js/input.js</files>
  <action>
Refactor the getInput() function to use keymap lookups instead of hardcoded key checks:

1. Add helper function getActiveKeyForAction(action):
   - Get boundKeys = keymap[action]
   - Loop through boundKeys array
   - Return first keyCode where keys[keyCode] is true
   - Return null if no key pressed

2. Add helper function isActionPressed(action):
   - Return getActiveKeyForAction(action) !== null

3. Refactor left movement handling:
   - Replace keys['ArrowLeft'] with getActiveKeyForAction('left')
   - Get keyCode from getActiveKeyForAction('left')
   - If keyCode exists, use keyTimers[keyCode] for DAS
   - Apply same DAS logic (elapsed < DAS_DELAY, lastRepeat === 0, etc.)

4. Refactor right movement handling:
   - Same pattern as left, using getActiveKeyForAction('right')

5. Refactor down handling:
   - Use isActionPressed('down') for soft drop
   - No DAS needed for down (continuous)

6. Refactor rotate handling:
   - Get keyCode from getActiveKeyForAction('rotate')
   - Use keyTimers[keyCode] for single-fire behavior
   - Check timer.lastRepeat === 0

7. Refactor hardDrop handling:
   - Get keyCode from getActiveKeyForAction('hardDrop')
   - Use keyTimers[keyCode] for single-fire

8. Refactor hold handling:
   - Get keyCode from getActiveKeyForAction('hold')
   - Use keyTimers[keyCode] for single-fire
   - This naturally handles multiple bound keys (C, ShiftLeft, ShiftRight)

9. Refactor pause handling:
   - Get keyCode from getActiveKeyForAction('pause')
   - Use keyTimers[keyCode] for single-fire

10. Call loadKeymap() at the end of setupInput():
    - After keydown/keyup listeners are set up
    - Ensures keymap is loaded when game starts
  </action>
  <verify>
Test refactored input:
- Open index.html in browser
- Arrow keys still move piece left/right
- Down arrow still soft drops
- Up arrow still rotates
- Space still hard drops
- C or Shift still holds piece
- P still pauses
- Console shows no errors
  </verify>
  <done>
getInput() uses keymap lookups for all 7 actions (left, right, down, rotate, hardDrop, hold, pause) with proper DAS/single-fire behavior preserved. loadKeymap() called in setupInput().
  </done>
</task>

<task type="auto">
  <name>Task 3: Update setupInput key prevention to use keymap</name>
  <files>js/input.js</files>
  <action>
Update the keydown event listener in setupInput() to prevent default for bound keys dynamically:

1. In the keydown handler, instead of checking hardcoded array:
   - OLD: if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code))
   - NEW: Check if e.code is bound to any action in keymap

2. Create helper function isGameKey(keyCode):
   - Loop through all actions in keymap
   - Check if any action's bound keys array includes keyCode
   - Return true if found, false otherwise

3. In keydown handler:
   - if (isGameKey(e.code)) { e.preventDefault(); }

4. This ensures that if user rebinds to WASD or other keys, those will also prevent default browser behavior (like W scrolling, Space activating buttons).
  </action>
  <verify>
Check that preventDefault works dynamically:
- Default arrow keys prevent scrolling
- If user later binds WASD, W should prevent scrolling when game is active
- Space prevents button activation
  </verify>
  <done>
Key prevention is dynamic: any key bound in keymap has default action prevented during gameplay, not just hardcoded arrow keys.
  </done>
</task>

</tasks>

<verification>
1. js/input.js contains DEFAULT_KEYMAP with 7 actions
2. loadKeymap, saveKeymap, restoreDefaults, getKeymap, setKeyBinding functions exist
3. getInput() uses keymap lookups (no hardcoded 'ArrowLeft', 'ArrowRight', etc. in conditionals)
4. setupInput() calls loadKeymap()
5. Game plays identically to before refactor (same DAS behavior, same controls)
6. localStorage shows tetris_keybindings key after first load
7. No JavaScript errors in console
</verification>

<success_criteria>
- All game actions use configurable keymap instead of hardcoded keys
- DAS (Delayed Auto Shift) still works correctly for left/right movement
- Single-fire behavior preserved for rotate, hardDrop, hold, pause
- Key bindings persist to localStorage as JSON
- restoreDefaults() returns keymap to DEFAULT_KEYMAP values
- BroadcastChannel posts KEYMAP_CHANGE on save
- Game is fully playable with default controls
</success_criteria>

<output>
After completion, create `.planning/phases/10-keyboard-remapping/10-01-SUMMARY.md`
</output>
