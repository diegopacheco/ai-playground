---
phase: 04-unique-mechanics
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - js/board.js
  - js/render.js
  - js/main.js
autonomous: true

must_haves:
  truths:
    - "Board grows by one row every 30 seconds"
    - "Existing pieces stay in correct positions after growth"
    - "Board stops growing at 30 rows maximum"
    - "Canvas height increases to show new rows"
    - "Grid lines extend to cover new rows"
  artifacts:
    - path: "js/board.js"
      provides: "growBoard function, MAX_ROWS constant, dynamic collision"
      contains: "MAX_ROWS"
    - path: "js/render.js"
      provides: "Dynamic grid and board rendering using board.length"
      contains: "board.length"
    - path: "js/main.js"
      provides: "Growth timer logic"
      contains: "growthTimer"
  key_links:
    - from: "js/main.js"
      to: "js/board.js"
      via: "growBoard() call in update()"
      pattern: "growBoard"
    - from: "js/board.js"
      to: "collision detection"
      via: "board.length instead of ROWS"
      pattern: "board.length"
    - from: "js/render.js"
      to: "dynamic canvas"
      via: "board.length for height calculations"
      pattern: "board.length"
---

<objective>
Implement board growth mechanics - board expands by adding rows at the bottom every 30 seconds up to a maximum of 30 rows.

Purpose: Creates the "growing board" mechanic that adds long-game strategy as players must adapt to an expanding playfield.
Output: Working board growth with proper collision detection, canvas resizing, and maximum size limit.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-unique-mechanics/04-RESEARCH.md
@.planning/phases/04-unique-mechanics/04-01-PLAN.md
@js/board.js
@js/render.js
@js/main.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add growBoard function and update collision detection</name>
  <files>js/board.js</files>
  <action>
Add MAX_ROWS constant at top of file after existing constants:
```javascript
const MAX_ROWS = 30;
```

Add growBoard function after clearLines():
```javascript
function growBoard(board, cols) {
    var newRow = [];
    for (var i = 0; i < cols; i++) {
        newRow.push(null);
    }
    board.push(newRow);
    return board;
}
```

Update isValidPosition() to use board.length instead of ROWS for bottom boundary:
- Change `newY >= ROWS` to `newY >= board.length`

Update lockPiece() to use board.length:
- Change `boardY < ROWS` to `boardY < board.length`

Update checkLines() to use board.length:
- Change `row < ROWS` to `row < board.length`
  </action>
  <verify>No immediate visual change, but collision detection now works with dynamic board height. Game should still function normally.</verify>
  <done>growBoard() function exists, collision detection uses board.length for dynamic height, MAX_ROWS constant defined at 30.</done>
</task>

<task type="auto">
  <name>Task 2: Update rendering for dynamic board height</name>
  <files>js/render.js</files>
  <action>
Update drawGrid() to use board parameter for height:
- Change function signature to `function drawGrid(board)`
- Replace all `ROWS * CELL_SIZE` with `board.length * CELL_SIZE` for height calculations
- Change grid line loop from `row <= ROWS` to `row <= board.length`

Update drawBoard() - already receives board, update loop:
- Change `row < ROWS` to `row < board.length`

Update drawClearingLines() to work with dynamic board (no changes needed, uses row indices).

Update drawGameOver() to use board parameter:
- Change signature to `function drawGameOver(board)`
- Replace `ROWS * CELL_SIZE` with `board.length * CELL_SIZE`

Update drawPaused() to use board parameter:
- Change signature to `function drawPaused(board)`
- Replace `ROWS * CELL_SIZE` with `board.length * CELL_SIZE`

Update drawFreezeOverlay() to use board parameter:
- Change signature to `function drawFreezeOverlay(remainingMs, board)`
- Replace `ROWS * CELL_SIZE` with `board.length * CELL_SIZE`

Update drawSidebar() to use board parameter:
- Change signature to `function drawSidebar(board)`
- Replace `ROWS * CELL_SIZE` with `board.length * CELL_SIZE`

Add resizeCanvas function:
```javascript
function resizeCanvas(board) {
    var dpr = window.devicePixelRatio || 1;
    var width = COLS * CELL_SIZE + SIDEBAR_WIDTH;
    var height = board.length * CELL_SIZE;

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';

    ctx.scale(dpr, dpr);
}
```
  </action>
  <verify>Game should still render correctly at initial 20-row size. All functions now accept board parameter for dynamic height.</verify>
  <done>All render functions use board.length for height calculations, resizeCanvas() function ready for board growth.</done>
</task>

<task type="auto">
  <name>Task 3: Add growth timer and wire everything together</name>
  <files>js/main.js</files>
  <action>
Add growthTimer variable after cycleTimer declarations:
```javascript
let growthTimer = 0;
```

In update() function, after the freeze cycle logic and before `if (gameState === GameState.FROZEN) return;`, add growth timer logic:
```javascript
growthTimer += deltaTime;
if (growthTimer >= boardGrowthInterval && board.length < MAX_ROWS) {
    board = growBoard(board, COLS);
    resizeCanvas(board);
    growthTimer = 0;
}
```

Update render() function calls to pass board parameter:
- `drawGrid(board)` instead of `drawGrid()`
- `drawSidebar(board)` instead of `drawSidebar()`
- `drawGameOver(board)` instead of `drawGameOver()`
- `drawPaused(board)` instead of `drawPaused()`
- `drawFreezeOverlay(FREEZE_DURATION - cycleTimer, board)` instead of `drawFreezeOverlay(FREEZE_DURATION - cycleTimer)`

Update resetGame() to reset growthTimer and recreate board at initial size:
```javascript
growthTimer = 0;
```

Update GROWTH_INTERVAL_CHANGE handler to clamp timer:
```javascript
else if (type === 'GROWTH_INTERVAL_CHANGE') {
    boardGrowthInterval = payload.interval;
    growthTimer = Math.min(growthTimer, boardGrowthInterval);
}
```

In resetGame(), after `board = createBoard();`, add canvas resize to reset to initial size:
```javascript
resizeCanvas(board);
```
  </action>
  <verify>Open index.html. After 30 seconds (or adjust boardGrowthInterval for faster testing), canvas should grow taller by one row. Grid extends, pieces stay in place. Growth stops at 30 rows.</verify>
  <done>Board grows every 30 seconds, canvas resizes to accommodate, growth stops at MAX_ROWS (30), admin growth interval control works.</done>
</task>

</tasks>

<verification>
1. Start game, note initial canvas height (20 rows)
2. Play for 30 seconds (or use admin panel to set shorter interval)
3. Canvas grows taller - one new empty row appears at bottom
4. Existing locked pieces stay in their positions (do not shift)
5. Grid lines extend to cover new row
6. Ghost piece correctly calculates landing on new bottom
7. Continue playing until board reaches 30 rows
8. Board stops growing at 30 rows (no further expansion)
9. Reset game (R key) - board returns to 20 rows
10. Admin panel growth interval slider changes timing of next growth
</verification>

<success_criteria>
- UNIQ-03: Board grows every 30s (configurable via admin)
- UNIQ-04: Growth preserves piece positions (pieces stay in place)
- UNIQ-05: Board has maximum size limit (30 rows)
- Canvas and grid resize correctly with board growth
- Collision detection works with dynamic board height
</success_criteria>

<output>
After completion, create `.planning/phases/04-unique-mechanics/04-02-SUMMARY.md`
</output>
