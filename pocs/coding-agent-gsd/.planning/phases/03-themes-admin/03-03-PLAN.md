---
phase: 03-themes-admin
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [js/sync.js, js/main.js, index.html]
autonomous: true

must_haves:
  truths:
    - "BroadcastChannel named 'tetris-sync' exists"
    - "Game responds to THEME_CHANGE messages"
    - "Game responds to SPEED_CHANGE messages"
    - "Game responds to POINTS_CHANGE messages"
    - "Game responds to STATS_REQUEST with STATS_RESPONSE"
    - "Level up cycles theme automatically"
    - "Channel closes on page unload"
  artifacts:
    - path: "js/sync.js"
      provides: "BroadcastChannel communication"
      exports: ["channel", "sendMessage", "handleMessage"]
    - path: "js/main.js"
      provides: "Message handling integration and theme cycling"
      contains: "channel.onmessage"
  key_links:
    - from: "js/sync.js"
      to: "BroadcastChannel"
      via: "new BroadcastChannel('tetris-sync')"
      pattern: "new BroadcastChannel\\('tetris-sync'\\)"
    - from: "js/main.js onLevelUp"
      to: "applyTheme"
      via: "theme cycling"
      pattern: "applyTheme.*THEME_ORDER"
---

<objective>
Create BroadcastChannel sync infrastructure and wire into game for real-time control.

Purpose: Enable admin panel (future) to control game in real-time. Game listens for messages and responds. Level up cycles through themes automatically.

Output: js/sync.js with channel setup, js/main.js with message handling and theme cycling on level up.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-themes-admin/03-RESEARCH.md

@js/main.js
@js/themes.js (from 03-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync.js with BroadcastChannel</name>
  <files>js/sync.js</files>
  <action>
Create js/sync.js with:

1. Create BroadcastChannel:
   const channel = new BroadcastChannel('tetris-sync');

2. Helper to send messages:
   function sendMessage(type, payload) {
     channel.postMessage({ type: type, payload: payload });
   }

3. Close channel on page unload (prevent memory leak per RESEARCH.md Pitfall 4):
   window.addEventListener('beforeunload', function() {
     channel.close();
   });

4. Message error handler:
   channel.addEventListener('messageerror', function(event) {
     console.error('Sync message error:', event);
   });

Do NOT set channel.onmessage here - that will be done in main.js where game state lives.
  </action>
  <verify>js/sync.js exists with BroadcastChannel('tetris-sync'), sendMessage function, beforeunload cleanup</verify>
  <done>sync.js creates channel, provides sendMessage, handles cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Wire message handling into main.js</name>
  <files>js/main.js</files>
  <action>
Add message handler in main.js after DOMContentLoaded setup:

channel.onmessage = function(event) {
  var data = event.data;
  var type = data.type;
  var payload = data.payload;

  if (type === 'THEME_CHANGE') {
    applyTheme(payload.themeName);
  }
  else if (type === 'SPEED_CHANGE') {
    dropInterval = payload.dropInterval;
  }
  else if (type === 'POINTS_CHANGE') {
    pointsPerRow = payload.pointsPerRow;
  }
  else if (type === 'GROWTH_INTERVAL_CHANGE') {
    boardGrowthInterval = payload.interval;
  }
  else if (type === 'STATS_REQUEST') {
    var currentThemeName = 'classic';
    for (var key in THEMES) {
      if (THEMES[key] === currentTheme) {
        currentThemeName = key;
        break;
      }
    }
    sendMessage('STATS_RESPONSE', {
      score: score,
      level: level,
      theme: currentThemeName,
      paused: isPaused,
      gameOver: gameOver
    });
  }
};

Add new game state variables at top of main.js:
  let pointsPerRow = 10;
  let boardGrowthInterval = 30000;

Update score calculation in update() to use pointsPerRow:
  score += result.linesCleared * pointsPerRow;

Update index.html to load sync.js after themes.js but before main.js.
  </action>
  <verify>main.js handles THEME_CHANGE, SPEED_CHANGE, POINTS_CHANGE, GROWTH_INTERVAL_CHANGE, STATS_REQUEST messages</verify>
  <done>Game responds to all admin control messages. pointsPerRow variable used for scoring.</done>
</task>

<task type="auto">
  <name>Task 3: Implement theme cycling on level up</name>
  <files>js/main.js</files>
  <action>
Modify onLevelUp function to cycle themes:

Add at top of main.js:
  let themeIndex = 0;

Update onLevelUp function:
  function onLevelUp() {
    themeIndex = (themeIndex + 1) % THEME_ORDER.length;
    var newTheme = THEME_ORDER[themeIndex];
    applyTheme(newTheme);
    sendMessage('THEME_CHANGE', { themeName: newTheme });
  }

This satisfies THEM-04: Level up cycles through themes. Also broadcasts theme change so admin panel stays in sync per RESEARCH.md Pitfall 1 (self-broadcasting).
  </action>
  <verify>onLevelUp function calls applyTheme and sendMessage with cycling theme</verify>
  <done>Level up cycles through classic->neon->retro->classic and broadcasts change</done>
</task>

</tasks>

<verification>
1. Open game in browser
2. In console: sendMessage('THEME_CHANGE', {themeName: 'neon'}) - game should change to neon theme
3. In console: sendMessage('SPEED_CHANGE', {dropInterval: 200}) - pieces should fall faster
4. Score 100 points (clear 10 rows) - theme should change on level up
5. Open second browser tab with game, change theme in one - other should change too
</verification>

<success_criteria>
- js/sync.js exists with channel, sendMessage, cleanup
- main.js handles all message types
- pointsPerRow variable controls scoring
- boardGrowthInterval variable exists (used in Phase 4)
- Level up cycles through themes
- Theme changes broadcast to other tabs
</success_criteria>

<output>
After completion, create `.planning/phases/03-themes-admin/03-03-SUMMARY.md`
</output>
